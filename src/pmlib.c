#include <stdlib.h>
#include <stdio.h>

int pbmread(char* path, int *mat, int row, int col){
    char buff[16];
    int c, x, y;
    FILE *fd = fopen(path,"r");
    //open file descriptor
    if(fd==NULL){
        fclose(fd);
        return -1;
    }
    //read image format
    if(!fgets(buff,sizeof(buff),fd)){//If you fail to read in file
        fclose(fd);
        return -1;
    }
    //Check the image format, pbm must be P1 or P4 (not too sure about the difference)
    if(buff[0]!='P' || (buff[1]!='1' && buff[1]!='4')){
        fclose(fd);
        return -1;
    }
    //Read until you skip the comments
    c = getc(fd);
    while(c == '#'){
        while(getc(fd) != '\n');
        c = getc(fd);
    }
    ungetc(c,fd);
    //read file size info
    if( fscanf(fd, "%d %d", &x, &y) !=2){ //Invalid file size
        fclose(fd);
        return -1;
    }
    //Check that the x and y match the file
    if(x!=row || y!=col){
        fclose(fd);
        return -1;
    }

    //I think this will move you to when the numbers actually start
    while (fgetc(fd) != '\n') ;
    
	int count = 0;
 	//while(fread(mat, 1, 4, fd)==4){
    while(1){
        fscanf(fd, "%d",mat);
 		mat++;
		count++;
		if(count==row*col){
			fclose(fd);
			return 0;
		}
	} 
	fclose(fd);
	return -2;	
    
}

int pgmread(char* path, int *mat, int row, int col){
    char buff[16];
    int c, x, y, d;
    FILE *fd = fopen(path,"r");
    //open file descriptor
    if(fd==NULL){
        fclose(fd);
        return -1;
    }
    //read image format
    if(!fgets(buff,sizeof(buff),fd)){//If you fail to read in file
        fclose(fd);
        return -1;
    }
    //Check the image format, pbm must be P1 or P4 (not too sure about the difference)
    if(buff[0]!='P' || (buff[1]!='2' && buff[1]!='5')){
        fclose(fd);
        return -1;
    }
    //Read until you skip the comments
    c = getc(fd);
    while(c == '#'){
        while(getc(fd) != '\n');
        c = getc(fd);
    }
    ungetc(c,fd);
    //read file size info
    if( fscanf(fd, "%d %d", &x, &y) !=2){ //Invalid file size
        fclose(fd);
        return -1;
    }
    //Check that the x and y match the file
    if(x!=col || y!=row){
        fclose(fd);
        return -1;
    }

    //Gotta read the depth component //For writing, we'll just assume it's 255
    if(fscanf(fd, "%d", &d) != 1){ //Failed to read the depth
        fclose(fd);
        return -1;
    }

    //I think this will move you to when the numbers actually start
    while (fgetc(fd) != '\n') ;
    
	int count = 0;
 	//while(fread(mat, 1, 4, fd)==4){
    while(1){
        fscanf(fd, "%d",mat);
 		mat++;
		count++;
		if(count==row*col){
			fclose(fd);
			return 0;
		}
	} 
	fclose(fd);
	return -2;	    
}

int ppmread(char* path, int *mr, int *mg, int *mb, int row, int col){
    char buff[16];
    int c, x, y, d;
    FILE *fd = fopen(path,"r");
    //open file descriptor
    if(fd==NULL){
        fclose(fd);
        return -1;
    }
    //read image format
    if(!fgets(buff,sizeof(buff),fd)){//If you fail to read in file
        fclose(fd);
        return -1;
    }
    //Check the image format, pbm must be P1 or P4 (not too sure about the difference)
    if(buff[0]!='P' || (buff[1]!='3' && buff[1]!='6')){
        fclose(fd);
        return -1;
    }
    //Read until you skip the comments
    c = getc(fd);
    while(c == '#'){
        while(getc(fd) != '\n');
        c = getc(fd);
    }
    ungetc(c,fd);
    //read file size info
    if( fscanf(fd, "%d %d", &x, &y) !=2){ //Invalid file size
        fclose(fd);
        return -1;
    }
    //Check that the x and y match the file
    if(x!=row || y!=col){
        fclose(fd);
        return -1;
    }

    //Gotta read the depth component //For writing, we'll just assume it's 255
    if(fscanf(fd, "%d", &d) != 1){ //Failed to read the depth
        fclose(fd);
        return -1;
    }

    //I think this will move you to when the numbers actually start
    while (fgetc(fd) != '\n') ;
    
	int count = 0;
 	//while((fread(mr, 1, 4, fd)==4)&&(fread(mg,1,4,fd)==4)&&(fread(mb,1,4,fd)==4)){
    while(1){
        fscanf(fd, "%d",mr);
        fscanf(fd, "%d",mg);
        fscanf(fd, "%d",mb);
 		mr++;
 		mg++;
 		mb++;
		count++;
		if(count==row*col){
			fclose(fd);
			return 0;
		}
	} 
	fclose(fd);
	return -2;	    
}

int pbmwrite(char* path, int *mat, int row, int col){
    FILE *fd = fopen(path,"w");
    //open file descriptor
    if(fd==NULL){
        fclose(fd);
        return -1;
    }

    //write the image format
    fprintf(fd, "P1\n");

    
    //Write a comment
    fprintf(fd, "#Autogenerated by MPL\n");

    //Write the file size
    fprintf(fd, "%d %d\n", row, col);
   
    //Write the actual bits in
    int count = 0;
    while(1){
        if(count%row != 0){
            fprintf(fd,"%d ", *mat);
        }
        else if(count%row==0){
            fprintf(fd,"%d\n",*mat);
        }
        count++;
        mat++;
        if(count==row*col){
			fclose(fd);
			return 0;
		}
    }
    
}

int pgmwrite(char* path, int *mat, int row, int col){
    FILE *fd = fopen(path,"w");
    //open file descriptor
    if(fd==NULL){
        fclose(fd);
        return -1;
    }

    //write the image format
    fprintf(fd, "P2\n");

    
    //Write a comment
    fprintf(fd, "#Autogenerated by MPL\n");

    //Write the file size
    fprintf(fd, "%d %d\n", col, row);

    //write the depth (assumed to be 255)
    fprintf(fd, "255\n");
   
    //Write the actual bits in
    int count = 0;
    while(1){
        if(count%row != 0){
            fprintf(fd,"%d ", *mat);
        }
        else if(count%row==0){
            fprintf(fd,"%d\n",*mat);
        }
        count++;
        mat++;
        if(count==row*col){
			fclose(fd);
			return 0;
		}
    }

	fclose(fd);
	return -2;	    
}

int ppmwrite(char* path, int *mr, int *mg, int *mb, int row, int col){
    FILE *fd = fopen(path,"w");
    //open file descriptor
    if(fd==NULL){
        fclose(fd);
        return -1;
    }

    //write the image format
    fprintf(fd, "P3\n");

    
    //Write a comment
    fprintf(fd, "#Autogenerated by MPL\n");

    //Write the file size
    fprintf(fd, "%d %d\n", row, col);

    //write the depth (assumed to be 255)
    fprintf(fd, "255\n");
   
    //Write the actual bits in
    int count = 0;
    while(1){
        if(count%row != 0){
            fprintf(fd,"%d ", *mr);
            fprintf(fd,"%d ", *mg);
            fprintf(fd,"%d ", *mb);
        }
        else if(count%row==0){
            fprintf(fd,"%d ", *mr);
            fprintf(fd,"%d ", *mg);
            fprintf(fd,"%d\n",*mb);
        }
        count++;
        mr++;
        mg++;
        mb++;
        if(count==row*col){
			fclose(fd);
			return 0;
		}
    }
	fclose(fd);
	return -2;	    
}

int main(){
    int height = 512;
    int width = 512;
    //int mat[height][width];
    int *mat = malloc(height*width*4);
    int *matr = malloc(height*width*4);
    int *matg = malloc(height*width*4);
    int *matb = malloc(height*width*4);
    pgmread("lena.pgm", mat, height, width);
    ppmread("lena.ppm", matr, matg, matb, height, width);
    pgmwrite("lena-out.pgm", mat, height, width);
    pgmwrite("lena-out-red.pgm", matr, height, width);
    pgmwrite("lena-out-green.pgm", matg, height, width);
    pgmwrite("lena-out-blue.pgm", matb, height, width);
    ppmwrite("lena-out.ppm", matr, matg, matb, height, width);

}
